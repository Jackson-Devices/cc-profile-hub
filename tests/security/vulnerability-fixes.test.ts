import { Mutex, MutexTimeoutError, MutexQueueFullError } from '../../src/utils/Mutex';
import { ProfileManager } from '../../src/profile/ProfileManager';
import { mkdir, rm } from 'fs/promises';
import { join } from 'path';

/**
 * Security tests verifying that vulnerabilities have been FIXED.
 * These tests prove that the implemented security measures work correctly.
 */

describe('SECURITY FIX: ProfileManager Race Condition', () => {
  let tempDir: string;
  let profilesPath: string;

  beforeEach(async () => {
    tempDir = `/tmp/security-test-${Date.now()}-${Math.random()}`;
    await mkdir(tempDir, { recursive: true });
    profilesPath = join(tempDir, 'profiles.json');
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('✅ FIX VERIFIED: File locking prevents data loss in concurrent creates', async () => {
    const manager = new ProfileManager(profilesPath);
    const promises = [];

    // Create 10 profiles concurrently
    for (let i = 0; i < 10; i++) {
      promises.push(
        manager.create(`profile-${i}`, {
          auth0Domain: `domain-${i}.auth0.com`,
          auth0ClientId: `client-${i}`,
          tokenStorePath: '/home/user/tokens',
        })
      );
    }

    await Promise.all(promises);

    // Verify NO data loss - all 10 profiles should exist
    const profiles = await manager.list();
    expect(profiles).toHaveLength(10);
    console.log(`✅ File locking prevented data loss: ${profiles.length}/10 profiles persisted`);
  });
});

describe('SECURITY FIX: Mutex Deadlock Prevention', () => {
  it('✅ FIX VERIFIED: Mutex times out after 30s instead of hanging forever', async () => {
    const mutex = new Mutex(); // Default 30s timeout
    const release = await mutex.acquire();
    // Never release - simulate stuck operation

    const start = Date.now();

    // Should timeout instead of hanging forever
    await expect(mutex.acquire()).rejects.toThrow(MutexTimeoutError);
    await expect(mutex.acquire()).rejects.toThrow('Mutex acquisition timed out after 30000ms');

    const elapsed = Date.now() - start;
    // Each acquire attempt times out after 30s
    expect(elapsed).toBeGreaterThanOrEqual(60000); // 2 attempts x 30s
    expect(elapsed).toBeLessThan(62000);

    console.log(`✅ Mutex timeout prevents deadlock: timed out after ${elapsed}ms`);

    release();
  }, 70000);

  it('✅ FIX VERIFIED: Custom timeout works correctly', async () => {
    const mutex = new Mutex({ timeoutMs: 500 });
    await mutex.acquire(); // Never release

    const start = Date.now();

    await expect(mutex.acquire()).rejects.toThrow(MutexTimeoutError);

    const elapsed = Date.now() - start;
    expect(elapsed).toBeGreaterThanOrEqual(500);
    expect(elapsed).toBeLessThan(600);

    console.log(`✅ Custom timeout works: ${elapsed}ms`);
  });
});

describe('SECURITY FIX: Mutex Queue Limit', () => {
  it('✅ FIX VERIFIED: Queue limit prevents unbounded growth', async () => {
    const mutex = new Mutex(); // Default queue limit: 1000
    await mutex.acquire(); // Never release

    const promises = [];

    // Try to queue 1010 waiters (1000 is the limit)
    for (let i = 0; i < 1010; i++) {
      promises.push(
        mutex.acquire().catch((e) => e)
      );
    }

    const results = await Promise.all(promises);

    // First 1000 should be queued (will timeout later)
    // Last 10 should fail immediately with MutexQueueFullError
    const queueFullErrors = results.filter(r => r instanceof MutexQueueFullError);

    expect(queueFullErrors.length).toBeGreaterThan(0);
    console.log(`✅ Queue limit enforced: ${queueFullErrors.length} requests rejected to prevent memory leak`);
  }, 35000); // Timeout before the mutex timeout triggers
});
